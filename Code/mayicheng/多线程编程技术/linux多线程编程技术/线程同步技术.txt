线程同步技术：

当有多个线程同时访问一块内存空间或者一个变量，一个文件描述符，如果不控制，那么有意想不到
的结果。


原子操作（对应到汇编就一条指令，那个指令时原子操作，不可再分割的）
（cpu同一时间只执行一个汇编指令）

i++

mov eax,i;
（mov ）		--->（出现不可预知的结果）
add  eax,i;


int i = 0;(不是原子操作)


互斥			（原子级操作）  （我感觉像是弄的像原子级操作）
他是一种锁或者信号灯。
互斥用来保护多个进程共享的数据和结构不会被同时修改，一个互斥锁只能有两个状态。
-locked      加锁
-unlocked    解锁
加锁后互斥不让其他线程访问。
任何时刻只能有一个线程来掌握某个互斥上锁。
一个线程如果试图在一个加锁的互斥上再加锁，这个线程会被挂起，直到加锁的线程释放掉互斥锁为止。


死锁：
某一个调用lock了，但是没用unlock，就死锁了（死锁程序就凉了，一定要避免死锁）
极端情况，pthread_cancel就gg了，锁没释放。。。。。。