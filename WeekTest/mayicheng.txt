c
层层paoxi，就能看到核心
主要还是这个东西   a[i][j] = *(*(a + i) + j) = i[a][j];

所以呢：这个3就相当于a一样，被放到里边去了，所以本应该是3[4]，而默认是int
所以这个&3[4]就是19
下一步同理 19是个地址   &19[5]     19 + 20 = 39		机智吧。。。




1.  6个helloworld，4个进程		---->>(加\n是6个，不加是8个，为什么从头开始执行真不知道。。。。)
        第0次，2个进程，2个helloworld
        第一次，4个进程，4个helloworld
        一共4个进程，6个helloworld

2.exec函数是替换当前执行的进程，换成我们写进去的进程，但是pid不变

3.打印的
Hello, my pid is %d
I was forked! :D %d
%d was forked!          （下面的两个%d是一样的。。。。。上面那个是父亲的）这个是打印的


管道的（我估计应该是这样）
管道的'<'  '>' 的机制一样，这个是单工的，一次只能传一个进程的数据，等把父进程的传完，再从头开始
传儿子的（fork之前的数据我估计是传传不过去，被阻塞了，所以这个pid还是之前父亲的），然后把下面再
传了(多次测试，感觉90%是这样)
~                                                                                              
~                                                                                              
~                                
